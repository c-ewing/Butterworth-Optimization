# Setup:
To test the Butterworth filter implementation first generate test files using either `generate_signals.ipynb` or `generate_test_signals.py`. Both generate the same test files, `generate_test_signals.py` is intended for automated testing as all options are configurable from the command line. The IPython notebook provides a visual representation of the signal files generated.

## Generated Signals
The scripts both generate five test signals: A DC signal with configurable ramp, Full/Half/Quarter Nyquist Signal, and an Impulse signal. 

### Impulse:
The most important signal for this project is the Impulse signal as it is used to test the frequency response of the filter.

### DC Signal:
The DC signal is used to characterize the filter under saturation conditions. This will reveal stability issues with the filter.

### Nyquist Signals:
Used to test the filter during extreme input oscillation.

# Analysis:
Analysis is completed either in `analyze_test_signals.[py|ipynb]` both provide similar functionality. The `.py` file is used to generate a frequency response plot based on the input and output files of the Butterworth filter program. The `.ipynb` file is used to create a response graph for the ideal, floating point, implementation of the Butterworth filter. This is done so the response of the fixed point program can be compared to that of the floating point implementation. Both plots contain the actual decibel difference between the input and output signals on the plots at the cutoff frequency. This is done to verify the properties of the filter. 

## `analyze_test_signals.py`
Takes five command line arguments:
- Input sample file (signal before filter processing)
- Output sample file (signal after the filtering is applied)
- `--sample-rate [int]` The sample rate of the sample files (Default: 22kHz)
- `--minimum-intensity [int]` The minimum intensity value possible in the sample files (Default: 0)
- `--maximum-intensity [int` The maximum intensity value possible in the sample files (Default: 65535)

After the program has completed a window will open with a frequency response chart. The chart has the magnitude (intensity/amplitude) of the signal on the vertical axis and the frequency of the signal on the horizontal axis.Unfiltered

## `analyze_test_signals.ipynb`
As noted above, this tool is similar to the `.py` file. However, instead of taking the output of the filter, it instead generates the ideal filter response curve for the specified filter parameters. A frequency response plot will again be generated within the notebook.

# Performance analysis:
Performance analysis was performed using the [callgrind](https://valgrind.org/docs/manual/cl-manual.html) tool within [valgrind](https://valgrind.org/). 

Performance is tested against `test_files/test_signal_impulse.dat`. The performance report is placed in the root of the git repo in the file `performance_report.txt`. This file can be generated using the command: `make callgrind`, which automatically builds the binary with debug symbols, generates the performance report, and interprets the report.

Callgrind generates an output fill that is interpreted using `callgrind_annotate` to retrieve the percentage of the applications run time that was spent in each function.

The tool [KCacheGrind](https://github.com/KDE/kcachegrind) was used to retrieve the number of instructions generated by the compiler. Using the `--dump-instr=yes` option for callgrind, the source code is annotated with the each assembly instructions generated for each line of code. This allows us to determine where the each instruction comes from for further optimization.

To view the report within KCacheGrind, open the generated `callgrind.out.*` file after running `make callgrind`